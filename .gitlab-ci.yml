stages:
  - validate
  - deploy
  - backup
  - monitor

variables:
  DOCKER_DRIVER: overlay2
  INSTALL_DIR: "/opt/decidim"
  DOMAIN: "decidev.DOMAIN_NAME.ext"
  EMAIL: "admin@DOMAIN_NAME.ext"

# Validate configuration files before deployment
validate_config:
  stage: validate
  image: ubuntu:22.04
  script:
    - echo "ğŸ” Validating configuration files..."
    - apt-get update -qq && apt-get install -y -qq docker-compose curl nginx
    
    # Check required files exist
    - echo "ğŸ“ Checking required files..."
    - |
      for file in docker-compose.yml nginx.conf backup.sh restore.sh .env.example; do
        if [ -f "$file" ]; then
          echo "âœ“ $file exists"
        else
          echo "âœ— $file missing"
          exit 1
        fi
      done
    
    # Validate docker-compose.yml syntax
    - echo ""
    - echo "ğŸ³ Validating docker-compose.yml..."
    - docker-compose -f docker-compose.yml config > /dev/null 2>&1
    - echo "âœ“ docker-compose.yml syntax is valid"
    
    # Check docker-compose services
    - |
      echo "ğŸ” Checking required services in docker-compose.yml..."
      required_services="postgres redis decidim nginx"
      for service in $required_services; do
        if grep -q "^  $service:" docker-compose.yml; then
          echo "âœ“ Service '$service' defined"
        else
          echo "âš  Service '$service' not found (optional check)"
        fi
      done
    
    # Validate nginx.conf syntax
    - echo ""
    - echo "ğŸ”€ Validating nginx.conf..."
    - nginx -t -c $(pwd)/nginx.conf 2>&1 | grep -q "successful" && echo "âœ“ nginx.conf syntax is valid" || echo "âš  nginx.conf syntax check skipped (may need server context)"
    
    # Check nginx.conf has required directives
    - |
      echo "ğŸ” Checking nginx.conf directives..."
      if grep -q "proxy_pass" nginx.conf; then
        echo "âœ“ proxy_pass directive found"
      else
        echo "âœ— proxy_pass directive missing"
        exit 1
      fi
      
      if grep -q "proxy_set_header Host" nginx.conf; then
        echo "âœ“ proxy_set_header Host found"
      else
        echo "âš  proxy_set_header Host missing (recommended)"
      fi
      
      if grep -q "client_max_body_size" nginx.conf; then
        echo "âœ“ client_max_body_size configured"
      else
        echo "âš  client_max_body_size not set (using default)"
      fi
    
    # Check .env.example has required variables
    - echo ""
    - echo "âš™ï¸  Checking .env.example configuration..."
    - |
      required_vars="POSTGRES_PASSWORD SECRET_KEY_BASE DOMAIN_NAME"
      for var in $required_vars; do
        if grep -q "^$var=" .env.example || grep -q "^# $var=" .env.example; then
          echo "âœ“ $var present in .env.example"
        else
          echo "âœ— $var missing from .env.example"
          exit 1
        fi
      done
    
    # Validate backup and restore scripts
    - echo ""
    - echo "ğŸ’¾ Checking backup scripts..."
    - |
      if [ -x backup.sh ] || grep -q "^#!/bin/bash" backup.sh; then
        echo "âœ“ backup.sh is a valid script"
      else
        echo "âš  backup.sh may not be executable"
      fi
      
      if [ -x restore.sh ] || grep -q "^#!/bin/bash" restore.sh; then
        echo "âœ“ restore.sh is a valid script"
      else
        echo "âš  restore.sh may not be executable"
      fi
    
    - echo ""
    - echo "âœ… All validation checks passed!"
  
  only:
    - branches

# Deploy to production
deploy_production:
  stage: deploy
  tags:
    - decidim-production  # Requires GitLab Runner with this tag
  environment:
    name: production
    url: https://$DOMAIN
  script:
    - echo "ğŸš€ Starting deployment to production..."
    
    # Prerequisite checks (similar to working script)
    - echo "ğŸ“‹ Running prerequisite checks..."
    
    # Check if Docker is installed and running
    - |
      if command -v docker &> /dev/null; then
        echo "âœ“ Docker is installed: $(docker --version)"
      else
        echo "âœ— Docker is not installed"
        exit 1
      fi
      
      if systemctl is-active --quiet docker; then
        echo "âœ“ Docker service is running"
      else
        echo "âœ— Docker service is not running"
        systemctl start docker || exit 1
      fi
    
    # Check if Nginx is installed
    - |
      if command -v nginx &> /dev/null; then
        echo "âœ“ Nginx is installed: $(nginx -v 2>&1)"
      else
        echo "âš  Nginx is not installed, attempting to install..."
        apt-get update -qq && apt-get install -y -qq nginx
      fi
    
    # Check DNS resolution
    - |
      echo "ğŸŒ Checking DNS resolution for $DOMAIN..."
      if host "$DOMAIN" > /dev/null 2>&1; then
        SERVER_IP=$(host "$DOMAIN" | grep "has address" | head -1 | awk '{print $4}')
        echo "âœ“ DNS resolves to: $SERVER_IP"
      else
        echo "âš  Warning: DNS resolution failed for $DOMAIN"
        echo "  Ensure DNS A record points to this server"
      fi
    
    # Check if ports 80 and 443 are available or in use by Nginx
    - |
      echo "ğŸ”Œ Checking ports 80 and 443..."
      for port in 80 443; do
        if ss -tuln 2>/dev/null | grep -q ":$port "; then
          echo "âš  Port $port is already in use (likely by Nginx)"
        else
          echo "âœ“ Port $port is available"
        fi
      done
    
    # Check disk space
    - |
      echo "ğŸ’¾ Checking disk space..."
      DISK_USAGE=$(df -h / | awk 'NR==2 {print $5}' | sed 's/%//')
      DISK_AVAIL=$(df -h / | awk 'NR==2 {print $4}')
      echo "  Available: $DISK_AVAIL (${DISK_USAGE}% used)"
      if [ "$DISK_USAGE" -gt 90 ]; then
        echo "âœ— Critical: Disk usage above 90%!"
        exit 1
      elif [ "$DISK_USAGE" -gt 85 ]; then
        echo "âš  Warning: Disk usage above 85%"
      else
        echo "âœ“ Disk space is adequate"
      fi
    
    - echo "âœ… All prerequisite checks passed!"
    - echo ""
    
    # Ensure installation directory exists
    - mkdir -p $INSTALL_DIR
    - cd $INSTALL_DIR
    
    # Copy project files
    - cp $CI_PROJECT_DIR/docker-compose.yml ./
    - cp $CI_PROJECT_DIR/nginx.conf ./
    - cp $CI_PROJECT_DIR/backup.sh ./
    - cp $CI_PROJECT_DIR/restore.sh ./
    - chmod +x backup.sh restore.sh
    
    # Validate copied configuration files
    - echo "ğŸ” Validating configuration files before deployment..."
    - |
      echo "Checking docker-compose.yml..."
      docker compose config > /dev/null 2>&1
      if [ $? -eq 0 ]; then
        echo "âœ“ docker-compose.yml is valid"
      else
        echo "âœ— docker-compose.yml validation failed"
        exit 1
      fi
    
    # Check nginx configuration
    - |
      echo "Checking nginx.conf..."
      if grep -q "proxy_pass" nginx.conf && grep -q "proxy_set_header" nginx.conf; then
        echo "âœ“ nginx.conf has required directives"
      else
        echo "âœ— nginx.conf is missing required directives"
        exit 1
      fi
    
    # Generate .env file if it doesn't exist (preserve existing config)
    - |
      if [ ! -f ".env" ]; then
        echo "ğŸ“ Creating .env file..."
        SECRET_KEY_BASE=$(openssl rand -hex 64)
        POSTGRES_PASSWORD=$(openssl rand -hex 32)
        cat > .env <<EOF
      # Database configuration
      POSTGRES_HOST=postgres
      POSTGRES_USER=decidim
      POSTGRES_PASSWORD=$POSTGRES_PASSWORD
      DATABASE_URL=postgres://decidim:$POSTGRES_PASSWORD@postgres/decidim_production

      # Rails configuration
      RAILS_ENV=production
      SECRET_KEY_BASE=$SECRET_KEY_BASE
      RAILS_SERVE_STATIC_FILES=true

      # Domain configuration
      DECIDIM_HOST=$DOMAIN
      DOMAIN_NAME=$DOMAIN

      # Redis configuration
      REDIS_URL=redis://redis:6379/0

      # Email configuration
      SMTP_ADDRESS=${SMTP_ADDRESS:-smtp.example.com}
      SMTP_PORT=${SMTP_PORT:-587}
      SMTP_USERNAME=${SMTP_USERNAME:-}
      SMTP_PASSWORD=${SMTP_PASSWORD:-}
      SMTP_DOMAIN=$DOMAIN
      EOF
        echo "âœ“ .env file created"
      else
        echo "âœ“ Using existing .env configuration"
      fi
    
    # Create necessary directories
    - mkdir -p postgres-data redis-data uploads backups
    - chmod -R 755 .
    
    # Pull latest Docker images
    - echo "ğŸ“¦ Pulling latest images..."
    - docker compose pull
    
    # Gracefully stop existing containers
    - echo "â¸ï¸  Stopping existing containers..."
    - docker compose down --timeout 30 || true
    
    # Start services
    - echo "â–¶ï¸  Starting services..."
    - docker compose up -d
    
    # Wait for services to be healthy
    - echo "â³ Waiting for services to be ready..."
    - sleep 20
    
    # Health check with retries
    - |
      echo "ğŸ¥ Running health checks..."
      MAX_ATTEMPTS=30
      ATTEMPT=0
      while [ $ATTEMPT -lt $MAX_ATTEMPTS ]; do
        if curl -sf http://localhost:3000/ > /dev/null 2>&1; then
          echo ""
          echo "âœ“ Decidim is ready and responding!"
          
          # Additional health checks
          echo ""
          echo "Running additional service checks..."
          
          # Check PostgreSQL
          if docker exec decidim-db pg_isready -U decidim > /dev/null 2>&1; then
            echo "âœ“ PostgreSQL is healthy"
          else
            echo "âš  PostgreSQL health check failed"
          fi
          
          # Check Redis
          if docker exec decidim-redis redis-cli ping > /dev/null 2>&1; then
            echo "âœ“ Redis is healthy"
          else
            echo "âš  Redis health check failed"
          fi
          
          # Check Nginx
          if systemctl is-active --quiet nginx; then
            echo "âœ“ Nginx is running"
          else
            echo "âš  Nginx is not running"
          fi
          
          break
        fi
        ATTEMPT=$((ATTEMPT + 1))
        echo -n "â³ Waiting for Decidim... attempt $ATTEMPT/$MAX_ATTEMPTS"
        sleep 10
      done
      
      if [ $ATTEMPT -eq $MAX_ATTEMPTS ]; then
        echo ""
        echo "âœ— Decidim failed to start within timeout (300 seconds)"
        echo "ğŸ“‹ Recent container logs:"
        docker compose logs --tail=50 decidim
        echo ""
        echo "ğŸ“Š Container status:"
        docker compose ps
        exit 1
      fi
    
    # Display running containers
    - echo "ğŸ“Š Running containers:"
    - docker compose ps
    
    # Update Nginx configuration if needed
    - |
      if ! grep -q "server_name $DOMAIN" /etc/nginx/sites-available/$DOMAIN 2>/dev/null; then
        echo "ğŸ”§ Updating Nginx configuration..."
        
        # Remove default site if it exists
        rm -f /etc/nginx/sites-enabled/default
        
        # Create new configuration
        cat > /etc/nginx/sites-available/$DOMAIN <<NGINX
      server {
          listen 80;
          server_name $DOMAIN;
          
          location / {
              proxy_pass http://127.0.0.1:3000;
              proxy_set_header Host \$host;
              proxy_set_header X-Real-IP \$remote_addr;
              proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
              proxy_set_header X-Forwarded-Proto \$scheme;
              proxy_buffering off;
              proxy_request_buffering off;
              client_max_body_size 100M;
          }
      }
      NGINX
        
        # Enable the site
        ln -sf /etc/nginx/sites-available/$DOMAIN /etc/nginx/sites-enabled/$DOMAIN
        
        # Test Nginx configuration before reloading
        echo "Testing Nginx configuration..."
        if nginx -t 2>&1; then
          echo "âœ“ Nginx configuration test passed"
          systemctl reload nginx
          echo "âœ“ Nginx reloaded successfully"
        else
          echo "âœ— Nginx configuration test failed"
          exit 1
        fi
      else
        echo "âœ“ Nginx configuration already exists for $DOMAIN"
      fi
    
    - echo "âœ… Deployment completed successfully!"
    - echo "ğŸŒ Site available at: https://$DOMAIN"
  
  only:
    - main
  
  when: manual  # Require manual trigger for production deployments
  allow_failure: false

# Automatic backup after successful deployment
backup_after_deploy:
  stage: backup
  tags:
    - decidim-production
  script:
    - echo "ğŸ’¾ Creating post-deployment backup..."
    - cd $INSTALL_DIR
    
    # Create timestamped backup directory
    - BACKUP_DIR="./backups/$(date +%Y-%m-%d_%H-%M-%S)_post_deploy"
    - mkdir -p "$BACKUP_DIR"
    
    # Backup PostgreSQL database
    - echo "ğŸ“Š Backing up database..."
    - docker exec decidim-db pg_dump -U decidim decidim_production > "$BACKUP_DIR/decidim_db.sql"
    - echo "âœ“ Database backup saved: $(du -h $BACKUP_DIR/decidim_db.sql | cut -f1)"
    
    # Backup uploads directory
    - |
      if [ -d "./uploads" ] && [ "$(ls -A ./uploads)" ]; then
        echo "ğŸ“ Backing up uploads..."
        cp -r ./uploads "$BACKUP_DIR/uploads"
        echo "âœ“ Uploads backup saved: $(du -sh $BACKUP_DIR/uploads | cut -f1)"
      else
        echo "â„¹ï¸  No uploads to backup"
      fi
    
    # Backup configuration
    - cp .env "$BACKUP_DIR/.env.backup"
    - cp docker-compose.yml "$BACKUP_DIR/docker-compose.yml.backup"
    - echo "âœ“ Configuration files backed up"
    
    # Create backup metadata
    - |
      cat > "$BACKUP_DIR/backup_info.txt" <<EOF
      Backup Date: $(date)
      Git Commit: $CI_COMMIT_SHORT_SHA
      Git Branch: $CI_COMMIT_BRANCH
      Pipeline ID: $CI_PIPELINE_ID
      Triggered By: $CI_COMMIT_AUTHOR
      EOF
    
    # Clean up old backups (keep last 7 days)
    - echo "ğŸ§¹ Cleaning up old backups..."
    - find ./backups -type d -mtime +7 -exec rm -rf {} + 2>/dev/null || true
    - echo "âœ“ Old backups cleaned (kept last 7 days)"
    
    - echo "âœ… Backup completed: $BACKUP_DIR"
    - ls -lh "$BACKUP_DIR"
  
  only:
    - main
  
  dependencies:
    - deploy_production
  
  when: on_success

# Manual rollback to previous backup
rollback:
  stage: deploy
  tags:
    - decidim-production
  script:
    - echo "âª Rolling back to previous version..."
    - cd $INSTALL_DIR
    
    # Find the most recent backup (excluding current)
    - LATEST_BACKUP=$(ls -td backups/*/ | head -2 | tail -1)
    
    - |
      if [ -z "$LATEST_BACKUP" ] || [ ! -d "$LATEST_BACKUP" ]; then
        echo "âœ— No backup found for rollback"
        exit 1
      fi
    
    - echo "ğŸ“¦ Restoring from: $LATEST_BACKUP"
    - cat "$LATEST_BACKUP/backup_info.txt" 2>/dev/null || echo "No backup info available"
    
    # Stop current services
    - echo "â¸ï¸  Stopping current services..."
    - docker compose down
    
    # Start only database for restore
    - echo "ğŸ”„ Starting database for restore..."
    - docker compose up -d postgres
    - sleep 10
    
    # Restore database
    - echo "ğŸ“Š Restoring database..."
    - docker exec -i decidim-db psql -U decidim decidim_production < "$LATEST_BACKUP/decidim_db.sql"
    - echo "âœ“ Database restored"
    
    # Restore uploads
    - |
      if [ -d "$LATEST_BACKUP/uploads" ]; then
        echo "ğŸ“ Restoring uploads..."
        rm -rf ./uploads
        cp -r "$LATEST_BACKUP/uploads" ./uploads
        echo "âœ“ Uploads restored"
      else
        echo "â„¹ï¸  No uploads to restore"
      fi
    
    # Restart all services
    - echo "â–¶ï¸  Restarting all services..."
    - docker compose up -d
    - sleep 20
    
    # Verify rollback
    - |
      if curl -sf http://localhost:3000/ > /dev/null 2>&1; then
        echo "âœ… Rollback completed successfully"
      else
        echo "âš ï¸  Rollback completed but service health check failed"
        docker compose logs --tail=50 decidim
        exit 1
      fi
  
  only:
    - main
  
  when: manual

# View application logs
view_logs:
  stage: monitor
  tags:
    - decidim-production
  script:
    - echo "ğŸ“‹ Viewing recent application logs..."
    - cd $INSTALL_DIR
    - docker compose logs --tail=100 decidim
    - echo ""
    - echo "ğŸ“Š Container status:"
    - docker compose ps
  
  only:
    - main
  
  when: manual
  allow_failure: true

# Comprehensive health check
health_check:
  stage: monitor
  tags:
    - decidim-production
  script:
    - echo "ğŸ¥ Running comprehensive health checks..."
    - echo "=== Decidim Deployment Diagnostics ==="
    - echo ""
    - cd $INSTALL_DIR
    
    # Check Docker installation and version
    - echo "ğŸ³ Docker Status:"
    - |
      if command -v docker &> /dev/null; then
        echo "âœ“ Docker is installed"
        docker --version
        docker compose version
      else
        echo "âœ— Docker is NOT installed"
        exit 1
      fi
    - echo ""
    
    # Check Docker services
    - echo "ğŸ“Š Container Status:"
    - docker compose ps
    - echo ""
    
    # Check individual service health
    - echo "ğŸ” Service Health Checks:"
    
    # Check Decidim application
    - echo ""
    - echo "  Decidim Application:"
    - |
      if curl -sf http://localhost:3000/ > /dev/null 2>&1; then
        echo "  âœ“ Decidim app is responding on localhost:3000"
        RESPONSE_CODE=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:3000/)
        echo "    HTTP Status: $RESPONSE_CODE"
      else
        echo "  âœ— Decidim app is NOT responding"
        exit 1
      fi
    
    # Check PostgreSQL
    - echo ""
    - echo "  PostgreSQL Database:"
    - |
      if docker exec decidim-db pg_isready -U decidim > /dev/null 2>&1; then
        echo "  âœ“ PostgreSQL is healthy"
        # Get database size and connection info
        docker exec decidim-db psql -U decidim -d decidim_production -c "SELECT pg_size_pretty(pg_database_size('decidim_production')) as size;" 2>/dev/null | grep -A 1 size || true
        docker exec decidim-db psql -U decidim -d decidim_production -c "SELECT COUNT(*) as tables FROM information_schema.tables WHERE table_schema = 'public';" 2>/dev/null | grep -A 1 tables || true
      else
        echo "  âœ— PostgreSQL is NOT healthy"
        exit 1
      fi
    
    # Check Redis
    - echo ""
    - echo "  Redis Cache:"
    - |
      if docker exec decidim-redis redis-cli ping > /dev/null 2>&1; then
        echo "  âœ“ Redis is healthy"
        REDIS_INFO=$(docker exec decidim-redis redis-cli info stats 2>/dev/null | grep total_connections_received || echo "")
        if [ -n "$REDIS_INFO" ]; then
          echo "    $REDIS_INFO"
        fi
      else
        echo "  âœ— Redis is NOT healthy"
        exit 1
      fi
    
    # Check Nginx
    - echo ""
    - echo "ğŸ”€ Nginx Reverse Proxy:"
    - |
      if systemctl is-active --quiet nginx; then
        echo "  âœ“ Nginx is running"
        NGINX_TEST=$(nginx -t 2>&1)
        if echo "$NGINX_TEST" | grep -q "successful"; then
          echo "  âœ“ Nginx configuration test successful"
        else
          echo "  âš  Nginx configuration test failed"
          echo "$NGINX_TEST"
        fi
      else
        echo "  âœ— Nginx is NOT running"
        exit 1
      fi
    
    # Check public connectivity
    - echo ""
    - echo "ğŸŒ Public Connectivity:"
    - |
      if curl -sf "http://$DOMAIN" > /dev/null 2>&1; then
        echo "  âœ“ Site accessible via HTTP"
      else
        echo "  âœ— Site NOT accessible via HTTP"
      fi
      
      if curl -sf "https://$DOMAIN" > /dev/null 2>&1; then
        echo "  âœ“ Site accessible via HTTPS"
      else
        echo "  âš  Site NOT accessible via HTTPS (may need SSL setup)"
      fi
    
    # Check SSL certificate
    - echo ""
    - echo "ğŸ”’ SSL Certificate:"
    - |
      if [ -d "/etc/letsencrypt/live/$DOMAIN" ]; then
        echo "  âœ“ SSL certificate exists"
        CERT_EXPIRY=$(openssl x509 -enddate -noout -in /etc/letsencrypt/live/$DOMAIN/fullchain.pem 2>/dev/null | cut -d= -f2)
        if [ -n "$CERT_EXPIRY" ]; then
          echo "    Expires: $CERT_EXPIRY"
          
          # Calculate days until expiry
          EXPIRY_EPOCH=$(date -d "$CERT_EXPIRY" +%s 2>/dev/null || echo "0")
          CURRENT_EPOCH=$(date +%s)
          DAYS_UNTIL_EXPIRY=$(( ($EXPIRY_EPOCH - $CURRENT_EPOCH) / 86400 ))
          
          if [ $DAYS_UNTIL_EXPIRY -lt 0 ]; then
            echo "    âœ— Certificate has EXPIRED!"
          elif [ $DAYS_UNTIL_EXPIRY -lt 30 ]; then
            echo "    âš  Certificate expires in $DAYS_UNTIL_EXPIRY days (renewal needed)"
          else
            echo "    âœ“ Certificate valid for $DAYS_UNTIL_EXPIRY days"
          fi
        fi
        
        # Check auto-renewal
        if systemctl is-active --quiet certbot.timer 2>/dev/null; then
          echo "  âœ“ Certbot auto-renewal is enabled"
        else
          echo "  âš  Certbot auto-renewal may not be enabled"
        fi
      else
        echo "  âš  SSL certificate not found (manual setup may be required)"
        echo "    Run: sudo certbot --nginx -d $DOMAIN"
      fi
    
    # Check disk space
    - echo ""
    - echo "ğŸ’¾ Disk Space:"
    - |
      DISK_USAGE=$(df -h $INSTALL_DIR | awk 'NR==2 {print $5}' | sed 's/%//')
      DISK_AVAIL=$(df -h $INSTALL_DIR | awk 'NR==2 {print $4}')
      DISK_USED=$(df -h $INSTALL_DIR | awk 'NR==2 {print $3}')
      echo "  Used: $DISK_USED / Available: $DISK_AVAIL (${DISK_USAGE}% used)"
      
      if [ "$DISK_USAGE" -gt 90 ]; then
        echo "  âœ— CRITICAL: Disk usage above 90%!"
      elif [ "$DISK_USAGE" -gt 85 ]; then
        echo "  âš  WARNING: Disk usage above 85%!"
      elif [ "$DISK_USAGE" -gt 70 ]; then
        echo "  âš  NOTICE: Disk usage above 70%"
      else
        echo "  âœ“ Disk space is adequate"
      fi
    
    # Check memory usage
    - echo ""
    - echo "ğŸ’» Memory Usage:"
    - free -h | grep -E "^Mem:|^Swap:" | awk '{print "  " $0}'
    - |
      MEM_USAGE=$(free | grep Mem | awk '{printf "%.0f", ($3/$2) * 100}')
      if [ "$MEM_USAGE" -gt 90 ]; then
        echo "  âš  Memory usage is high (${MEM_USAGE}%)"
      else
        echo "  âœ“ Memory usage is acceptable (${MEM_USAGE}%)"
      fi
    
    # Check container resource usage
    - echo ""
    - echo "ğŸ“ˆ Container Resource Usage:"
    - docker stats --no-stream --format "table {{.Name}}\t{{.CPUPerc}}\t{{.MemUsage}}" $(docker compose ps -q) 2>/dev/null || echo "  Unable to retrieve container stats"
    
    # Count backups
    - echo ""
    - echo "ğŸ’¾ Backup Status:"
    - |
      if [ -d "backups" ]; then
        BACKUP_COUNT=$(ls -d backups/*/ 2>/dev/null | wc -l)
        echo "  Total backups: $BACKUP_COUNT"
        if [ $BACKUP_COUNT -gt 0 ]; then
          LATEST=$(ls -td backups/*/ 2>/dev/null | head -1)
          LATEST_NAME=$(basename $LATEST)
          LATEST_SIZE=$(du -sh $LATEST 2>/dev/null | cut -f1)
          echo "  Latest: $LATEST_NAME (Size: $LATEST_SIZE)"
          
          # Check backup age
          LATEST_TIME=$(stat -c %Y $LATEST 2>/dev/null || stat -f %m $LATEST 2>/dev/null)
          CURRENT_TIME=$(date +%s)
          BACKUP_AGE_HOURS=$(( ($CURRENT_TIME - $LATEST_TIME) / 3600 ))
          
          if [ $BACKUP_AGE_HOURS -gt 48 ]; then
            echo "  âš  Latest backup is $BACKUP_AGE_HOURS hours old"
          else
            echo "  âœ“ Latest backup is $BACKUP_AGE_HOURS hours old"
          fi
        else
          echo "  âš  No backups found"
        fi
      else
        echo "  âš  Backup directory not found"
      fi
    
    # Recent logs summary
    - echo ""
    - echo "ğŸ“‹ Recent Error Logs (if any):"
    - docker compose logs --tail=20 decidim 2>/dev/null | grep -i "error\|exception\|fatal" || echo "  âœ“ No recent errors found in logs"
    
    - echo ""
    - echo "================================================"
    - echo "âœ… Health check completed!"
    - echo "================================================"
  
  only:
    - main
  
  when: manual
  allow_failure: true

# Scheduled daily backup (configure in GitLab CI/CD Schedules)
scheduled_backup:
  stage: backup
  tags:
    - decidim-production
  script:
    - echo "ğŸ• Running scheduled backup..."
    - cd $INSTALL_DIR
    - bash backup.sh
    - echo "âœ… Scheduled backup completed"
  
  only:
    - schedules
  
  allow_failure: false
